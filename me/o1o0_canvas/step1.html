<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="utf-8" />
        <title>ãƒ¯ãƒ©ãƒ™ãƒ³ãƒãƒ£ãƒ¼</title>
        <link rel="shortcut icon" type="image/png" href="{% static 'favicon.ico' %}" />
        <!--                                                ===================
                                                            1
            1. Example: `http://example.com/static/favicon.ico`
                                            ==================
        -->
        <style>
            /* ç”»é¢å…¨ä½“ã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ã™ã‚‹ãŸã‚ã®è¨­å®šã€‚ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ãŒå‡ºã¦ã“ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã€ãƒãƒ¼ã‚¸ãƒ³ã‚’ç„¡ãã™ */
            body {
                margin: 0;
                overflow: hidden;
            }
        </style>
        <!-- 3D -->
        <script src="https://unpkg.com/three@0.140.2/build/three.min.js"></script>
        <!-- `gl-matrix-min.js` - mat4 ã‚’å«ã‚€ -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>

        <script>
            // ãƒšãƒ¼ã‚¸ã®èª­ã¿è¾¼ã¿ã‚’å¾…ã¤
            window.addEventListener("DOMContentLoaded", init);

            function init() {
                //
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ»ã‚µã‚¤ã‚ºè¨­å®š
                //
                const width = 960;
                const height = 540;

                //
                // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ä½œæˆ
                //
                const renderer = new THREE.WebGLRenderer({
                    canvas: document.querySelector("#myCanvas"),
                });

                // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼è¨­å®š
                // èƒŒæ™¯ãŒçœŸã£æš—ãªã®ã‚’æ­¢ã‚ã‚‹
                // ğŸ“– [three.jsã®èƒŒæ™¯ã‚’é€æ˜è‰²ã¾ãŸã¯ä»–ã®è‰²ã«å¤‰æ›´ã™ã‚‹](https://qastack.jp/programming/16177056/changing-three-js-background-to-transparent-or-other-color)
                renderer.setClearColor(0xffccff, 1);

                //
                // ãƒãƒ†ãƒªã‚¢ãƒ«ä½œæˆ
                //
                const material = new THREE.MeshStandardMaterial({
                    color: 0xab83e9, // RGB
                    side: THREE.DoubleSide,
                });

                //
                // ã‚¸ã‚ªãƒ¡ãƒˆãƒªï¼ˆå›³å½¢ï¼‰ä½œæˆ
                //
                const geometryList = [
                    new THREE.SphereGeometry(50), // çƒä½“
                    new THREE.BoxGeometry(100, 100, 100), // ç›´æ–¹ä½“
                    new THREE.PlaneGeometry(100, 100), // å¹³é¢
                    new THREE.TetrahedronGeometry(100, 0), // ä¸‰è§’éŒ
                    new THREE.ConeGeometry(100, 100, 32), // å††éŒ
                    new THREE.CylinderGeometry(50, 50, 100, 32), // å††æŸ±
                    new THREE.TorusGeometry(50, 30, 16, 100), // ãƒ‰ãƒ¼ãƒŠãƒ„å½¢çŠ¶
                ];

                //
                // ã‚·ãƒ¼ãƒ³ä½œæˆ
                //
                const scene = new THREE.Scene();

                //
                // ã‚«ãƒ¡ãƒ©ä½œæˆ
                //
                const camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
                camera.position.set(0, 500, +1000);
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                //
                // å…‰æºä½œæˆ
                //
                // - å¹³è¡Œå…‰æº
                const directionalLight = new THREE.DirectionalLight(0xffffff);
                directionalLight.position.set(1, 1, 1);

                //
                // ç’°å¢ƒå…‰ä½œæˆ
                //
                const ambientLight = new THREE.AmbientLight(0x999999);

                //
                // ã‚³ãƒ³ãƒ†ãƒŠãƒ¼ä½œæˆï¼ˆãƒ¡ãƒƒã‚·ãƒ¥ã®é›†ã¾ã‚Šã«ã‚ãŸã‚‹æ¦‚å¿µçš„ãªã‚‚ã®ï¼‰
                //
                const container = new THREE.Object3D();

                //
                // ã‚·ãƒ¼ãƒ³æ§‹æˆ
                //
                // å…‰æº
                scene.add(directionalLight);
                // ç’°å¢ƒå…‰
                scene.add(ambientLight);
                // ã‚³ãƒ³ãƒ†ãƒŠãƒ¼
                scene.add(container);

                //
                // å›³å½¢ã®åˆæœŸè¨­å®š
                //
                geometryList.map((geometry, index) => {
                    // å½¢çŠ¶ã¨ãƒãƒ†ãƒªã‚¢ãƒ«ã‹ã‚‰ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ä½œæˆã—ã¾ã™
                    const mesh = new THREE.Mesh(geometry, material);

                    // 3Dè¡¨ç¤ºã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®sceneãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¼ãŒ3Dè¡¨ç¤ºç©ºé–“ã¨ãªã‚Šã¾ã™
                    container.add(mesh);

                    // å††å‘¨ä¸Šã«é…ç½®
                    mesh.position.x = 400 * Math.sin((index / geometryList.length) * Math.PI * 2);
                    mesh.position.z = 400 * Math.cos((index / geometryList.length) * Math.PI * 2);
                });

                // æ¯ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚ã«å®Ÿè¡Œã•ã‚Œã‚‹ãƒ«ãƒ¼ãƒ—ã‚¤ãƒ™ãƒ³ãƒˆã§ã™
                function tick() {
                    // ãƒ¡ãƒƒã‚·ãƒ¥ã‚’å›è»¢ã•ã›ã‚‹
                    container.rotation.y += 0.01;
                    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                    renderer.render(scene, camera);

                    requestAnimationFrame(tick);
                }

                tick();

                // åˆæœŸåŒ–æ™‚ã«ï¼‘å›å®Ÿè¡Œ
                onResize();
                // ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿæ™‚ã«å®Ÿè¡Œ
                window.addEventListener("resize", onResize);

                /**
                 * ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿæ™‚ã«å®Ÿè¡Œ
                 */
                function onResize() {
                    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ»ã‚µã‚¤ã‚ºå–å¾—
                    const width = window.innerWidth;
                    const height = window.innerHeight;

                    // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚µã‚¤ã‚ºèª¿æ•´
                    renderer.setPixelRatio(window.devicePixelRatio);
                    renderer.setSize(width, height);

                    // ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’æ­£ã™
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                }
            }
        </script>
    </head>
    <body>
        <canvas id="myCanvas"></canvas>
    </body>
</html>

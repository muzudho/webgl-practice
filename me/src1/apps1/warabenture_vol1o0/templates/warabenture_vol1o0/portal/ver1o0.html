{% load static %} {# 👈あとで static "URL" を使うので load static します #}
<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="utf-8" />
        <title>ワラベンチャー</title>
        <link rel="shortcut icon" type="image/png" href="{% static 'favicon.ico' %}" />
        <!--                                                ===================
                                                            1
            1. Example: `http://example.com/static/favicon.ico`
                                            ==================
        -->
        <!-- 3D -->
        <script src="https://unpkg.com/three@0.140.2/build/three.min.js"></script>
        <!-- `gl-matrix-min.js` - mat4 を含む -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>

        <script src="{% static 'webglFacade.js' %}"></script>
        <script src="{% static 'webglScript.js' %}"></script>

        <script>
            // ページの読み込みを待つ
            window.addEventListener("DOMContentLoaded", init);

            function init() {
                // シェーダー・スクリプトのファイルパスの配列
                const shaderScriptPaths = ["../static/texture/vertex_shader.glsl", "../static/texture/fragment_shader.glsl"];
                // const imagePath = "../static/texture/2016_09_texture.png";
                const imagePath = "../static/202101__character__28--kifuwarabe-futsu.png";
                webgl_setup(shaderScriptPaths, imagePath);

                // サイズを指定
                const width = 960;
                const height = 540;

                // レンダラーを作成
                const renderer = new THREE.WebGLRenderer({
                    canvas: document.querySelector("#myCanvas"),
                });
                renderer.setSize(width, height);
                // 背景が真っ暗なのを止める
                // 📖 [three.jsの背景を透明色または他の色に変更する](https://qastack.jp/programming/16177056/changing-three-js-background-to-transparent-or-other-color)
                renderer.setClearColor(0xffffff, 0);

                // シーンを作成
                const scene = new THREE.Scene();

                // カメラを作成
                const camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
                camera.position.set(0, 500, +1000);
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                // コンテナーを作成
                const container = new THREE.Object3D();
                scene.add(container);

                // マテリアルを作成
                const material = new THREE.MeshStandardMaterial({
                    color: 0xab83e9, // RGB
                    side: THREE.DoubleSide,
                });

                // 平行光源を作成
                const directionalLight = new THREE.DirectionalLight(0xffffff);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                // 環境光を作成
                const ambientLight = new THREE.AmbientLight(0x999999);
                scene.add(ambientLight);

                // ジオメトリ（図形）を作成
                const geometryList = [
                    new THREE.SphereGeometry(50), // 球体
                    new THREE.BoxGeometry(100, 100, 100), // 直方体
                    new THREE.PlaneGeometry(100, 100), // 平面
                    new THREE.TetrahedronGeometry(100, 0), // 三角錐
                    new THREE.ConeGeometry(100, 100, 32), // 円錐
                    new THREE.CylinderGeometry(50, 50, 100, 32), // 円柱
                    new THREE.TorusGeometry(50, 30, 16, 100), // ドーナツ形状
                ];

                geometryList.map((geometry, index) => {
                    // 形状とマテリアルからメッシュを作成します
                    const mesh = new THREE.Mesh(geometry, material);

                    // 3D表示インスタンスのsceneプロパティーが3D表示空間となります
                    container.add(mesh);

                    // 円周上に配置
                    mesh.position.x = 400 * Math.sin((index / geometryList.length) * Math.PI * 2);
                    mesh.position.z = 400 * Math.cos((index / geometryList.length) * Math.PI * 2);
                });

                tick();

                // 毎フレーム時に実行されるループイベントです
                function tick() {
                    // メッシュを回転させる
                    container.rotation.y += 0.01;
                    // レンダリング
                    renderer.render(scene, camera);

                    requestAnimationFrame(tick);
                }
            }
        </script>
    </head>
    <body>
        <canvas id="myCanvas"></canvas>
    </body>
</html>

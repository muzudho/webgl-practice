<html>
    <head>
        <meta charset="utf-8" />
        <script src="https://unpkg.com/three@0.140.2/build/three.min.js"></script>
        <script>
            // ãƒšãƒ¼ã‚¸ã®èª­ã¿è¾¼ã¿ã‚’å¾…ã¤
            window.addEventListener("DOMContentLoaded", init);

            function init() {
                // ã‚µã‚¤ã‚ºã‚’æŒ‡å®š
                const width = 960;
                const height = 540;

                // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã‚’ä½œæˆ
                const renderer = new THREE.WebGLRenderer({
                    canvas: document.querySelector("#myCanvas"),
                });
                renderer.setSize(width, height);
                // èƒŒæ™¯ãŒçœŸã£æš—ãªã®ã‚’æ­¢ã‚ã‚‹
                // ğŸ“– [three.jsã®èƒŒæ™¯ã‚’é€æ˜è‰²ã¾ãŸã¯ä»–ã®è‰²ã«å¤‰æ›´ã™ã‚‹](https://qastack.jp/programming/16177056/changing-three-js-background-to-transparent-or-other-color)
                renderer.setClearColor(0xffffff, 0);

                // ã‚·ãƒ¼ãƒ³ã‚’ä½œæˆ
                const scene = new THREE.Scene();

                // ã‚«ãƒ¡ãƒ©ã‚’ä½œæˆ
                const camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
                camera.position.set(0, 500, +1000);
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                // ã‚³ãƒ³ãƒ†ãƒŠãƒ¼ã‚’ä½œæˆ
                const container = new THREE.Object3D();
                scene.add(container);

                // ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ
                const material = new THREE.MeshStandardMaterial({
                    color: 0xab83e9, // RGB
                    side: THREE.DoubleSide,
                });

                // å¹³è¡Œå…‰æºã‚’ä½œæˆ
                const directionalLight = new THREE.DirectionalLight(0xffffff);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                // ç’°å¢ƒå…‰ã‚’ä½œæˆ
                const ambientLight = new THREE.AmbientLight(0x999999);
                scene.add(ambientLight);

                // ã‚¸ã‚ªãƒ¡ãƒˆãƒªï¼ˆå›³å½¢ï¼‰ã‚’ä½œæˆ
                const geometryList = [
                    new THREE.SphereGeometry(50), // çƒä½“
                    new THREE.BoxGeometry(100, 100, 100), // ç›´æ–¹ä½“
                    new THREE.PlaneGeometry(100, 100), // å¹³é¢
                    new THREE.TetrahedronGeometry(100, 0), // ä¸‰è§’éŒ
                    new THREE.ConeGeometry(100, 100, 32), // å††éŒ
                    new THREE.CylinderGeometry(50, 50, 100, 32), // å††æŸ±
                    new THREE.TorusGeometry(50, 30, 16, 100), // ãƒ‰ãƒ¼ãƒŠãƒ„å½¢çŠ¶
                ];

                geometryList.map((geometry, index) => {
                    // å½¢çŠ¶ã¨ãƒãƒ†ãƒªã‚¢ãƒ«ã‹ã‚‰ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ä½œæˆã—ã¾ã™
                    const mesh = new THREE.Mesh(geometry, material);

                    // 3Dè¡¨ç¤ºã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®sceneãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¼ãŒ3Dè¡¨ç¤ºç©ºé–“ã¨ãªã‚Šã¾ã™
                    container.add(mesh);

                    // å††å‘¨ä¸Šã«é…ç½®
                    mesh.position.x = 400 * Math.sin((index / geometryList.length) * Math.PI * 2);
                    mesh.position.z = 400 * Math.cos((index / geometryList.length) * Math.PI * 2);
                });

                tick();

                // æ¯ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚ã«å®Ÿè¡Œã•ã‚Œã‚‹ãƒ«ãƒ¼ãƒ—ã‚¤ãƒ™ãƒ³ãƒˆã§ã™
                function tick() {
                    // ãƒ¡ãƒƒã‚·ãƒ¥ã‚’å›è»¢ã•ã›ã‚‹
                    container.rotation.y += 0.01;
                    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                    renderer.render(scene, camera);

                    requestAnimationFrame(tick);
                }
            }
        </script>
    </head>
    <body>
        <canvas id="myCanvas"></canvas>
    </body>
</html>
